# USING AWS SERVERLESS SERVICES TO BUILD A TASK MANAGEMENT SYSTEM

### Instruction:
***Design and implement a Task Management System for a field team using AWS serverless services. The system should allow an admin to create and assign tasks to team members. Team members log in to view and update their assigned tasks, while the admin oversees all tasks, team assignments, and deadlines. The system must handle task notifications, status updates, and deadline tracking efficiently, ensuring a seamless workflow.***


### Tools Used:
- AWS Lambda Functions
    * Post Confirmation Trigger
    * Create Task
    * Retrieve Users From Cognito
    * Send Task Reminders
    * Retrieve Created Tasks
    * Update Task Status
    * Delete Task
    * Retrieve Task By Id
    
- AWS API Gateway
    * Cognito User Management API [GET]
    * Create New Task [POST]
    * Delete Task By ID [DELETE]
    * Get All Tasks [GET]
    * Get Task By Id [GET]
    * Update Task Status [PATCH]

- AWS Cognito
    * User Pool
    * User Groups
    * Extensions
    * Client side integrations

- AWS Simple Notification Service (SNS)
    * Topics
    * Subscriptions
    * Filter Policies

- AWS DynamoDB
    * Tables
    * Items
    * Queries

- AWS EventBridge
    * Buses
    * Rules
    * Targets

- AWS IAM Roles
    * Assigning roles to AWS services

- Vite + React.js
    * Integrating with Cognito for authentication
    * Integrating with AWS API Gateway and Lambda


## AWS Lambda Functions

### Post Confirmation Trigger
Whenever a user signs up and is confirmed as a valid user through email verification ( or other means ) on AWS Cognito, it triggers this lambda function to perform the following operations on the data that has been passed down to it. 
```python
import json
import boto3

sns_client = boto3.client('sns')
cognito_client = boto3.client('cognito-idp')

SNS_TOPIC_ARN = "arn:aws:sns:region:********:function-name"
GROUP_NAME = "Non-Administrative-Group-Name"
USER_POOL_ID = "************"
```
It initialises the boto3 client, and sets values for SNS topic arn, cognito user pool id and user pool group name.

```python
def lambda_handler(event, context):
```
When AWS Cognito calls a trigger ( such as the post confirmation trigger ), it passes and `event` to the trigger. This event is captured in the event parameter of the lambda_handler.

```python
username = event['userName']
email = event['request']['userAttributes']['email']
user_id = event['request']['userAttributes']['sub']
```
Retrieve the username the user used to signup, their email and the sub (unique id generated by cognito on user confirmation)

```python
filter_policy = {
    'email': [email],
    'group': [GROUP_NAME]
}
```
Creates a filter policy using the user's email and the group they will be placed in

```python
sns_response = sns_client.subscribe(
    TopicArn=SNS_TOPIC_ARN,
    Protocol='email',
    Endpoint=email,
    Attributes={
        'FilterPolicy': json.dumps(filter_policy)
    }
)
```
Subscribes the user to an SNS topic and attaches a filter policy to it. The filter policy is important because when we want to send emails to that particular person and no one else, we can specify that person as the target recipient in our message attributes.

```python
cognito_response = cognito_client.admin_add_user_to_group(
    UserPoolId=USER_POOL_ID,
    Username=email,
    GroupName=GROUP_NAME
)
```
It then adds the user to a new group ( Non administrative group ).

```python
return event
```
returns the event after successfully subscribing the user to an sns topic so they would receive mails, and putting them in a group to differentiate who is an admin, and who is a regular user ( member )

### Create Task Function
This lambda function is broken down into three core layers.
* saving a task to the database
```python
body = json.loads(event.get('body', '{}'))

task_id = create_task_id()
task_item = {
    'id': task_id,
    'title': body['title'],
    'description': body.get('description', ''),
    'files': [],
    'status': 'not-started',
    'start_date': body['startDate'],
    'due_date': body['dueDate'],
    'assigned_to': body['assigned_to'],
    'completed_by': []
}

tasks_table.put_item(Item=task_item)
```

* notify the assigned users that they have been assigned a task
```python
message = (
    f"You have been assigned a new task:\n\n"
    f"Title: {title}\n"
    f"Start Date: {start_date}\n"
    f"Due Date: {due_date}\n\n"
    f"Please check the system for more details."
)
subject = f"New Task Assigned: {title}"

for email in emails:
    sns.publish(
        TopicArn=SNS_TOPIC_ARN,
        Subject=subject,
        Message=message,
        MessageAttributes={
            'email': {
                'DataType': 'String',
                'StringValue': email
            },
            'group': {
                'DataType': 'String',
                'StringValue': GROUP_NAME
            }
        }
    )
```
* schedule a cron job to remind users when deadline is approaching
```python
lambda_client = boto3.client('lambda')
eventbridge = boto3.client('events')

reminder_time = datetime.strptime(due_date, '%Y-%m-%d') - timedelta(days=1)

reminder_time_hour = reminder_time.replace(hour=8, minute=0, second=0, microsecond=0)
reminder_time_iso = reminder_time_hour.strftime('%Y-%m-%dT%H:%M:%S') + "Z"

rule_name = f"TaskReminder_{task_id}"

cron_expression = f"cron(43 9 {reminder_time_hour.day} {reminder_time_hour.month} ? {reminder_time_hour.year})"

eventbridge.put_rule(
    Name=rule_name,
    ScheduleExpression=cron_expression,
    State='ENABLED'
)

eventbridge.put_targets(
    Rule=rule_name,
    Targets=[
        {
            'Id': f"ReminderTarget_{task_id}",
            'Arn': 'arn:aws:lambda:eu-west-1:241533136420:function:sendTaskReminder',
            'Input': json.dumps({
                'task_id': task_id,
                'title': title,
                'due_date': due_date,
                'assigned_emails': assigned_emails
            })
        }
    ]
)
```

### Retrieve Users From Cognito
```python   
while True:
    if pagination_token:
        response = cognito_client.list_users_in_group(
            UserPoolId=USER_POOL_ID,
            GroupName=GROUP_NAME,
            NextToken=pagination_token
        )
    else:
        response = cognito_client.list_users_in_group(
            UserPoolId=USER_POOL_ID,
            GroupName=GROUP_NAME
        )
    
    for user in response['Users']:
        user_info = {
            'Username': user['Username'],
            'Email': None,
            'Sub': None
        }
        
        for attr in user['Attributes']:
            if attr['Name'] == 'email':
                user_info['Email'] = attr['Value']
            elif attr['Name'] == 'sub':
                user_info['Sub'] = attr['Value']
        
        users.append(user_info)
    
    pagination_token = response.get('NextToken')
    if not pagination_token:
        break
return users
```

#### Logic: Pagination Handling
**Description**:  
The while loop initiates a process that handles pagination. If there is a `pagination_token`, the request to `list_users_in_group` includes this token to fetch the next set of results. If no `pagination_token` is present, the request fetches the first page of results. This ensures the code can process large sets of data by making multiple requests if necessary.

---

#### Logic: Calling `list_users_in_group` API
**Description**:  
The function calls the AWS Cognito API `list_users_in_group` to fetch users from a specific user group. It provides either a `NextToken` (if it's handling paginated data) or omits it for the first call. This allows fetching users in a specific group within a user pool from Cognito.

---

#### Logic: Iterating Over Users
**Description**:  
Once a response is received from Cognito, the code iterates over the users in the `response['Users']` list. Each user is processed one by one to extract their relevant information (such as `Username`, `Email`, and `Sub`). This allows further processing or storage of user details.

---

#### Logic: Extracting User Attributes
**Description**:  
For each user, the code iterates through their `Attributes` field. It checks for specific attribute names ('email' and 'sub') and extracts their corresponding values. The extracted values are stored in a dictionary for each user, which is then appended to the `users` list for further processing.

---

#### Logic: Storing User Information
**Description**:  
The code creates a dictionary `user_info` for each user, initially setting `'Username'`, `'Email'`, and `'Sub'` to `None`. As the user attributes are processed, the relevant fields are populated (e.g., if the attribute 'email' is found, the `Email` field is updated). This structured data is then added to the `users` list for future reference.

---

#### Logic: Pagination Token Update
**Description**:  
After processing the current batch of users, the function checks for a `NextToken` in the response. This token indicates whether there are more users to fetch. If a `NextToken` exists, the loop continues to request more data. If no token is returned, the loop terminates, indicating all users have been processed.

---

#### Logic: Breaking the Loop
**Description**:  
The loop will break when there is no `pagination_token` returned from the `list_users_in_group` API. This signifies that all pages of results have been fetched and no further requests to the API are necessary. The function then proceeds to return the list of users.

---

#### Logic: Returning Users
**Description**:  
Once the loop finishes fetching and processing all user data, the final `users` list, which contains the relevant user information, is returned. This provides the caller with a complete set of user details, including their usernames, email addresses, and `sub` identifiers.


### Send Task Reminders
```python
task = event
        
message = (
    f"Reminder: You have an upcoming task deadline.\n\n"
    f"Title: {task['title']}\n"
    f"Due Date: {task['due_date']}\n\n"
    f"Please complete your task before the deadline."
)
subject = f"Task Reminder: {task['title']}"
print(task['assigned_emails'])

for email in task['assigned_emails']:
    sns.publish(
        TopicArn=SNS_TOPIC_ARN,
        Subject=subject,
        Message=message,
        MessageAttributes={
            'email': {
                'DataType': 'String',
                'StringValue': email
            },
            'group': {
                'DataType': 'String',
                'StringValue': GROUP_NAME
            }
        }
    )

rule_name = f"TaskReminder_{task['task_id']}"
target_id = f"ReminderTarget_{task['task_id']}"
print(f"Deleting EventBridge Rule: {rule_name}")

event_bridge.remove_targets(
    Rule=rule_name,
    Ids=[target_id]
)

event_bridge.delete_rule(
    Name=rule_name
)
```
### Logic: Constructing Reminder Message
**Description**:  
A reminder message is being created using formatted strings. It includes the task title, due date, and a reminder to complete the task before the deadline. The message is dynamically populated using the task's data (`task['title']` and `task['due_date']`), ensuring the reminder is personalized for each task.

---

### Logic: Defining the Email Subject
**Description**:  
The subject of the email is constructed using the task title. The string `f"Task Reminder: {task['title']}"` ensures the email subject directly relates to the specific task being reminded, making the email more relevant to the recipient.

---

### Logic: Iterating Over Assigned Emails
**Description**:  
The code loops through each email in `task['assigned_emails']` and sends a reminder for the task to each assigned user. This ensures that each user who is assigned the task receives the relevant reminder email.

---

### Logic: Publishing Message to SNS Topic
**Description**:  
For each email address in the list, the `sns.publish()` method is used to send the reminder message to the assigned users. The message is sent via the AWS Simple Notification Service (SNS) to a specified SNS topic (`SNS_TOPIC_ARN`). Message attributes, including the recipient's email and a group identifier, are included to provide additional metadata about the message.

---

### Logic: Removing EventBridge Rule Targets
**Description**:  
After sending the reminder notifications, the script proceeds to clean up the EventBridge rule by removing its targets. It uses the `event_bridge.remove_targets()` method to remove a target associated with the specific rule. The target ID (`target_id`) is constructed dynamically based on the task ID.

---

### Logic: Deleting EventBridge Rule
**Description**:  
Once the target has been removed, the `event_bridge.delete_rule()` method is called to delete the EventBridge rule itself. The rule name is dynamically created based on the task ID. This ensures that once the task reminder has been sent, any associated scheduling rule is deleted, avoiding unnecessary future triggers.

---

### Logic: Printing Logs
**Description**:  
The `print()` statements are used to log the task's assigned emails and the deletion of the EventBridge rule. These log statements help with debugging and provide visibility into which emails are being used for sending reminders and confirm the rule deletion process.

---

### Logic: Rule Name and Target ID Construction
**Description**:  
The rule name and target ID are dynamically constructed using the task's `task_id`. This ensures that each task has a unique rule and target, which is necessary to manage multiple reminders and their associated cleanup efficiently. The naming convention avoids any conflicts between different tasks.

## AWS Simple Notification Service (SNS) - User Subscription and Filter Policies

### Overview
In this application, we utilize AWS Simple Notification Service (SNS) to send task assignment and reminders via email. Users are subscribed to specific SNS topics, and filter policies are applied to control which messages they receive. This setup allows us to send targeted task reminders to the appropriate users, ensuring the right notifications are delivered efficiently and only to those who need them.

### Subscribing Users to SNS Topics
To send notifications to users, we first create an SNS topic for task reminders. Each user that needs to receive notifications is subscribed to this topic via their email address. Once subscribed, these users will be able to receive task reminders whenever a message is published to the topic.

### Filter Policies for Targeted Emails
SNS allows us to attach **filter policies** to subscriptions, enabling the system to deliver messages only when certain conditions are met. In this case, filter policies are crucial because they allow us to send specific reminders to users based on the attributes of the tasks.

For example, we might want to send reminders only for high-priority tasks, or tasks that belong to specific user groups. By attaching filter policies, we ensure that each user receives only the notifications that are relevant to them, based on the attributes attached to the SNS message.

### How SNS Works
SNS uses a **publish-subscribe** model where:
- A **publisher** (in this case, the system sending task reminders) publishes messages to a topic.
- A **subscriber** (the user) receives the message if they are subscribed to the topic and the message matches any filter policies attached to their subscription.

Without filter policies, all subscribers to a topic would receive every message published to it, which could result in unnecessary or irrelevant notifications. Filter policies allow for more granular control, ensuring users receive only the information that pertains to them.

## AWS Cognito Integration with React Application

### Overview
In this application, AWS Cognito is used to manage user authentication and authorization. The system is set up to differentiate between two user groups: **members** and **administrators**. AWS Cognito's user pool handles the user registration process, assigns users to appropriate groups, and manages user authentication. This setup enables us to effectively control user access and implement role-based features in the React application.

### AWS Cognito - User Pool
A **Cognito User Pool** was created to store and manage user data. This user pool is responsible for handling the registration, login, and management of users in the system. It provides built-in features for user sign-up, sign-in, password management, and email verification, ensuring secure and efficient authentication.

Key Steps:
1. **Create User Pool**: A user pool was created in AWS Cognito to serve as the authentication backend for the app.
2. **Set Up Sign-Up and Sign-In Flows**: Configured sign-up and sign-in policies, including email verification and password rules.
   
### AWS Cognito - User Groups
To control access to different parts of the application, two user groups were created in the Cognito User Pool:

- **Members (Precedence 2)**: This group is for regular users who sign up through the React client. They have lower precedence than administrators and are granted access to standard features of the application.
- **Administrators (Precedence 1)**: This group is for users with higher privileges (e.g., admin users). They can manage system settings and users. A user manually added to this group has a higher precedence.

Upon creating the groups, we defined the necessary permissions and roles that each group would have within the application.

### AWS Cognito - Extensions
To automate the process of assigning users to groups based on their role, AWS Cognito was extended using the **Post Confirmation Trigger**. This trigger is invoked after a user confirms their sign-up (e.g., after they verify their email address).

- **Post Confirmation Trigger**: This AWS Lambda function is executed when a user successfully confirms their registration. It pulls user data and assigns users to the appropriate group. 
   - **Admin Assignment**: A manual process was used to assign admin users to the **Administrators** group.
   - **Member Assignment**: Any user who signs up through the React app is automatically placed in the **Members** group.

This extension ensures that the user’s group membership is handled automatically and is consistent with their role.

### Client-Side Integrations (React Application)
In the React client, we integrated AWS Cognito to handle user authentication and interaction with the user pool.

#### Sign-Up Flow:
- Users are able to sign up for the application through the **React client**.
- On form submission, the app calls the Cognito **SignUp API** to register the user, including the necessary information such as email, password, etc.
- By default, users who sign up through the app are added to the **Members** group.

#### Post-Sign-Up Flow:
- Once the user confirms their registration (via email verification), the **Post Confirmation Trigger** assigns them to the correct group in Cognito.
- After the user is placed in the correct group, the application can retrieve and check their group information using the **GetUser** API to customize the user experience based on their role.

#### Sign-In Flow:
- After signing up, users can sign in through the React application using the **Cognito Identity Provider API** to authenticate.
- The app uses the Cognito **Authentication API** to handle login, manage user sessions, and provide authentication tokens for secure access to other resources.


## AWS EventBridge in This Context

### Overview
In this application, **AWS EventBridge** is utilized to manage event-driven tasks like sending reminders for upcoming task deadlines. EventBridge acts as the event bus and scheduling mechanism that triggers Lambda functions based on predefined schedules. It allows us to decouple different components of the system, automate processes, and create an event-driven architecture for tasks like sending reminders.


### AWS EventBridge Components

#### 1. **Event Buses**
An **event bus** is the core component of EventBridge. It acts as the communication channel that allows events to be routed from producers (such as tasks or user activities) to consumers (such as Lambda functions or other services). In this context, the default event bus is used for event routing, but you could create custom event buses for more isolated event handling.

EventBridge's event buses ensure that tasks such as sending reminders or managing events based on time are handled asynchronously and efficiently.

#### 2. **Rules**
**Rules** in EventBridge are used to match incoming events and route them to appropriate targets, such as Lambda functions. Rules are created with specific **schedule expressions** (like cron expressions), filtering the events that are processed and triggering actions at predefined times.

In this context, a rule is created to schedule task reminders. Here’s how it works:
- When a task’s due date is close, the reminder is scheduled to trigger one day before the task’s due date at 8:00 AM.
- The rule is created dynamically based on the task's due date, using a cron expression to trigger at the specific time.

Example:
```python
cron_expression = f"cron(43 9 {reminder_time_hour.day} {reminder_time_hour.month} ? {reminder_time_hour.year})"
```
This cron expression schedules the event at 8:43 AM on the day before the task's due date. The rule is then created using the `put_rule` method, and it is associated with the task reminder function.

#### 3. **Targets**
**Targets** are the destinations for events that match the rule’s criteria. In this case, the target is a **Lambda function** (`sendTaskReminder`) that will be triggered when the rule is invoked. When the task reminder is due, EventBridge will invoke the Lambda function and pass relevant data (such as task ID, title, due date, and assigned emails) as input to the Lambda function.

The `put_targets` API is used to link the rule to the Lambda function, and the input data (task details) is passed in a JSON format.

Example:
```python
eventbridge.put_targets(
    Rule=rule_name,
    Targets=[{
        'Id': f"ReminderTarget_{task_id}",
        'Arn': 'arn:aws:lambda:eu-west-1:******:function:sendTaskReminder',
        'Input': json.dumps({
            'task_id': task_id,
            'title': title,
            'due_date': due_date,
            'assigned_emails': assigned_emails
        })
    }]
)
```

### EventBridge's Role in the Application Workflow

1. **Task Reminder Scheduling**:
   - The system calculates when to send the task reminder (1 day before the due date).
   - A cron-based **EventBridge rule** is created with a schedule expression based on the task's due date.
   - This rule is designed to trigger at 8:00 AM on the day before the task is due, ensuring the reminder is sent at the correct time.

2. **Triggering Lambda Function**:
   - Once the EventBridge rule is triggered at the specified time, it invokes the `sendTaskReminder` Lambda function.
   - The Lambda function receives the task data (e.g., task title, due date, assigned emails) and processes the reminder message.

3. **Sending Reminders via SNS**:
   - Inside the Lambda function, an SNS message is sent to the list of assigned emails with the task reminder.
   - The SNS message includes task details, subject, and message body to notify the recipients about the upcoming deadline.

4. **Cleaning Up EventBridge Rules**:
   - After the reminder is sent, the **EventBridge rule** is deleted and its target (the Lambda function) is removed using the `remove_targets` and `delete_rule` methods. This cleanup ensures that expired reminders do not trigger future events.

### Permissions Setup (Context C)
For EventBridge to invoke a Lambda function, appropriate permissions need to be set. This is done by adding a policy that allows EventBridge to invoke the Lambda function.

Example:
```bash
aws lambda add-permission --function-name sendTaskReminder --statement-id "AllowEventBridgeInvoke" --action "lambda:InvokeFunction" --principal events.amazonaws.com --source-arn arn:aws:events:<region>:<account-id>:rule/TaskReminder_*
```
This command grants EventBridge permission to invoke the Lambda function for any rules related to task reminders.


### Key Benefits of Using AWS EventBridge in This Context

1. **Decoupling Components**:
   - EventBridge enables a decoupled architecture, where different components (e.g., task creation, reminder scheduling, and email sending) operate independently but are coordinated through events. This simplifies the overall workflow.

2. **Automated Task Reminders**:
   - By scheduling reminders using EventBridge rules, we can automate the process of notifying users about upcoming tasks, reducing manual intervention and ensuring timely notifications.

3. **Scalability**:
   - EventBridge scales automatically to handle large numbers of events. As task reminders grow in number, EventBridge can efficiently trigger Lambda functions to send notifications without needing manual intervention or complex scaling setups.

4. **Flexibility and Customization**:
   - Using cron expressions for scheduling gives us flexibility in when and how reminders are triggered, allowing us to easily adjust the timing based on task due dates or user preferences.

5. **Clean Resource Management**:
   - By removing targets and deleting rules after the reminder is triggered, the system ensures that unused resources (EventBridge rules) are cleaned up, preventing unnecessary cost accumulation and ensuring that the system remains optimized.
# serverless-lambda-functions
